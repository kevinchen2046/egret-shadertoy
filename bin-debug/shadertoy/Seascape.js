var shadertoy;
(function (shadertoy) {
    shadertoy.Seascape = "\n    //afl_ext 2017-2023\n\n    // Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n    \n    #define DRAG_MULT 0.048\n    #define ITERATIONS_RAYMARCH 13\n    #define ITERATIONS_NORMAL 48\n    \n    #define Mouse (iMouse.xy / iResolution.xy)\n    #define Resolution (iResolution.xy)\n    #define Time (iTime)\n    \n    vec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n        float x = dot(direction, position) * frequency + timeshift * speed;\n        float wave = exp(sin(x) - 1.0);\n        float dx = wave * cos(x);\n        return vec2(wave, -dx);\n    }\n    \n    float getwavesRaymarch(vec2 position){\n        float iter = 0.0;\n        float phase = 6.0;\n        float speed = 2.0;\n        float weight = 1.0;\n        float w = 0.0;\n        float ws = 0.0;\n        for(int i=0;i<ITERATIONS_RAYMARCH;i++){\n            vec2 p = vec2(sin(iter), cos(iter));\n            vec2 res = wavedx(position, p, speed, phase, Time);\n            position += p * res.y * weight * DRAG_MULT;\n            w += res.x * weight;\n            iter += 12.0;\n            ws += weight;\n            weight = mix(weight, 0.0, 0.2);\n            phase *= 1.18;\n            speed *= 1.07;\n        }\n        return w / ws;\n    }\n    float getwavesNormal(vec2 position){\n        float iter = 0.0;\n        float phase = 6.0;\n        float speed = 2.0;\n        float weight = 1.0;\n        float w = 0.0;\n        float ws = 0.0;\n        for(int i=0;i<ITERATIONS_NORMAL;i++){\n            vec2 p = vec2(sin(iter), cos(iter));\n            vec2 res = wavedx(position, p, speed, phase, Time);\n            position += p * res.y * weight * DRAG_MULT;\n            w += res.x * weight;\n            iter += 12.0;\n            ws += weight;\n            weight = mix(weight, 0.0, 0.2);\n            phase *= 1.18;\n            speed *= 1.07;\n        }\n        return w / ws;\n    }\n    float raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\n        vec3 pos = start;\n        float h = 0.0;\n        float hupper = depth;\n        float hlower = 0.0;\n        vec2 zer = vec2(0.0);\n        vec3 dir = normalize(end - start);\n        for(int i=0;i<318;i++){\n            h = getwavesRaymarch(pos.xz * 0.1) * depth - depth;\n            if(h + 0.01 > pos.y) {\n                return distance(pos, camera);\n            }\n            pos += dir * (pos.y - h);\n        }\n        return -1.0;\n    }\n    \n    float H = 0.0;\n    vec3 normal(vec2 pos, float e, float depth){\n        vec2 ex = vec2(e, 0);\n        H = getwavesNormal(pos.xy * 0.1) * depth;\n        vec3 a = vec3(pos.x, H, pos.y);\n        return normalize(cross((a-vec3(pos.x - e, getwavesNormal(pos.xy * 0.1 - ex.xy * 0.1) * depth, pos.y)), \n                               (a-vec3(pos.x, getwavesNormal(pos.xy * 0.1 + ex.yx * 0.1) * depth, pos.y + e))));\n    }\n    mat3 rotmat(vec3 axis, float angle)\n    {\n        float s = sin(angle);\n        float c = cos(angle);\n        float oc = 1.0 - c;\n        return mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n    }\n    \n    vec3 getRay(vec2 uv){\n        uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\n        vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\n        if(Resolution.x < 600.0) return proj;\n        vec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * ((Mouse.x + 0.5) * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((Mouse.y * 1.5) * 2.0 - 1.0)) * proj;\n        return ray;\n    }\n    \n    float intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\n    { \n        return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n    }\n    \n    vec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\n        sundir.y = max(sundir.y, -0.07);\n        float special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\n        float special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\n        float raysundt = pow(abs(dot(sundir, raydir)), 2.0);\n        float sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\n        float mymie = sundt * special_trick * 0.2;\n        vec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\n        vec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\n        vec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\n        bluesky2 *= special_trick * (0.24 + raysundt * 0.24);\n        return bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;\n    } \n    vec3 getatm(vec3 ray){\n         return extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\n        \n    }\n    \n    float sun(vec3 ray){\n         vec3 sd = normalize(vec3(1.0));   \n        return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\n    }\n    vec3 aces_tonemap(vec3 color){\t\n        mat3 m1 = mat3(\n            0.59719, 0.07600, 0.02840,\n            0.35458, 0.90834, 0.13383,\n            0.04823, 0.01566, 0.83777\n        );\n        mat3 m2 = mat3(\n            1.60475, -0.10208, -0.00327,\n            -0.53108,  1.10813, -0.07276,\n            -0.07367, -0.00605,  1.07602\n        );\n        vec3 v = m1 * color;    \n        vec3 a = v * (v + 0.0245786) - 0.000090537;\n        vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n        return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n    }\n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n        fragCoord.y*=uTextureSize.y/uTextureSize.x;\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        uv.y=1.0-uv.y;\n        float waterdepth = 2.1;\n        vec3 wfloor = vec3(0.0, -waterdepth, 0.0);\n        vec3 wceil = vec3(0.0, 0.0, 0.0);\n        vec3 orig = vec3(0.0, 2.0, 0.0);\n        vec3 ray = getRay(uv);\n        float hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n        if(ray.y >= -0.01){\n            vec3 C = getatm(ray) * 2.0 + sun(ray);\n            //tonemapping\n            C = aces_tonemap(C);\n             fragColor = vec4( C,1.0);   \n            return;\n        }\n        float lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\n        vec3 hipos = orig + ray * hihit;\n        vec3 lopos = orig + ray * lohit;\n        float dist = raymarchwater(orig, hipos, lopos, waterdepth);\n        vec3 pos = orig + ray * dist;\n    \n        vec3 N = normal(pos.xz, 0.001, waterdepth);\n        vec2 velocity = N.xz * (1.0 - N.y);\n        N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\n        vec3 R = reflect(ray, N);\n        float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n        \n        vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R) + vec3(0.0293, 0.0698, 0.1717);\n        //tonemapping\n        C = aces_tonemap(C);\n        \n        fragColor = vec4(C,1.0);\n    }";
})(shadertoy || (shadertoy = {}));
